# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/tests/02_rpc/test_exceptions_aio.ipynb

__all__ = ['test_close_in_worker_task', 'test_close_propagates_to_other_channel', 'test_exception_hierarchy', 'test_multiple_close_is_safe', 'test_recv_after_close', 'test_recv_no_timeout_blocks', 'test_recv_receives_shutdown_from_close', 'test_recv_timeout', 'test_recv_timeout_preserves_channel', 'test_recv_various_timeouts', 'test_send_after_close', 'test_try_recv_after_close', 'test_try_recv_receives_shutdown_from_close', 'test_try_recv_returns_none_not_timeout']

# %% nbs/tests/02_rpc/test_exceptions_aio.ipynb 2
import pytest
import asyncio
import time
from netrun.rpc.base import (
    ChannelClosed,
    ChannelBroken,
    RecvTimeout,
    RPCError,
)
from netrun.rpc.aio import (
    create_async_channel_pair,
)

# %% nbs/tests/02_rpc/test_exceptions_aio.ipynb 5
@pytest.mark.asyncio
async def test_send_after_close():
    """AsyncChannel.send() raises ChannelClosed after close()."""
    ch_a, ch_b = create_async_channel_pair()

    await ch_a.close()
    assert ch_a.is_closed

    with pytest.raises(ChannelClosed) as exc_info:
        await ch_a.send("test", "data")

    assert "closed" in str(exc_info.value).lower()

# %% nbs/tests/02_rpc/test_exceptions_aio.ipynb 7
@pytest.mark.asyncio
async def test_recv_after_close():
    """AsyncChannel.recv() raises ChannelClosed after close()."""
    ch_a, ch_b = create_async_channel_pair()

    await ch_a.close()

    with pytest.raises(ChannelClosed):
        await ch_a.recv()

# %% nbs/tests/02_rpc/test_exceptions_aio.ipynb 9
@pytest.mark.asyncio
async def test_try_recv_after_close():
    """AsyncChannel.try_recv() raises ChannelClosed after close()."""
    ch_a, ch_b = create_async_channel_pair()

    await ch_a.close()

    with pytest.raises(ChannelClosed):
        await ch_a.try_recv()

# %% nbs/tests/02_rpc/test_exceptions_aio.ipynb 12
@pytest.mark.asyncio
async def test_recv_receives_shutdown_from_close():
    """When ch_b closes, ch_a.recv() raises ChannelClosed via shutdown signal."""
    ch_a, ch_b = create_async_channel_pair()

    # Close ch_b - this sends shutdown to ch_a
    await ch_b.close()

    # ch_a should receive the shutdown signal
    with pytest.raises(ChannelClosed) as exc_info:
        await ch_a.recv(timeout=1.0)

    assert "shut down" in str(exc_info.value).lower()
    assert ch_a.is_closed

# %% nbs/tests/02_rpc/test_exceptions_aio.ipynb 14
@pytest.mark.asyncio
async def test_try_recv_receives_shutdown_from_close():
    """When ch_b closes, ch_a.try_recv() raises ChannelClosed via shutdown signal."""
    ch_a, ch_b = create_async_channel_pair()

    # Close ch_b - this sends shutdown to ch_a
    await ch_b.close()

    # Give a moment for the message to be available
    await asyncio.sleep(0.01)

    with pytest.raises(ChannelClosed):
        await ch_a.try_recv()

    assert ch_a.is_closed

# %% nbs/tests/02_rpc/test_exceptions_aio.ipynb 17
@pytest.mark.asyncio
async def test_close_propagates_to_other_channel():
    """When one channel closes, the other's recv() raises ChannelClosed."""
    ch_a, ch_b = create_async_channel_pair()

    # Close channel A
    await ch_a.close()

    # Channel B should receive the shutdown signal
    with pytest.raises(ChannelClosed):
        await ch_b.recv(timeout=1.0)

# %% nbs/tests/02_rpc/test_exceptions_aio.ipynb 19
@pytest.mark.asyncio
async def test_close_in_worker_task():
    """Worker task receives ChannelClosed when main closes."""
    ch_a, ch_b = create_async_channel_pair()

    worker_exception = []

    async def worker():
        try:
            while True:
                await ch_b.recv()
        except ChannelClosed as e:
            worker_exception.append(e)

    task = asyncio.create_task(worker())

    # Give worker time to start
    await asyncio.sleep(0.01)

    # Close from main
    await ch_a.close()

    await asyncio.wait_for(task, timeout=1.0)

    assert len(worker_exception) == 1
    assert isinstance(worker_exception[0], ChannelClosed)

# %% nbs/tests/02_rpc/test_exceptions_aio.ipynb 22
@pytest.mark.asyncio
async def test_multiple_close_is_safe():
    """Multiple close() calls are safe."""
    ch_a, ch_b = create_async_channel_pair()

    await ch_a.close()
    await ch_a.close()
    await ch_a.close()

    assert ch_a.is_closed

# %% nbs/tests/02_rpc/test_exceptions_aio.ipynb 26
@pytest.mark.asyncio
async def test_recv_timeout():
    """AsyncChannel.recv() raises RecvTimeout when timeout expires."""
    ch_a, ch_b = create_async_channel_pair()

    start = time.time()
    with pytest.raises(RecvTimeout) as exc_info:
        await ch_a.recv(timeout=0.1)
    elapsed = time.time() - start

    assert elapsed >= 0.1
    assert elapsed < 0.5
    assert "timed out" in str(exc_info.value).lower()

# %% nbs/tests/02_rpc/test_exceptions_aio.ipynb 28
@pytest.mark.asyncio
async def test_recv_timeout_preserves_channel():
    """After RecvTimeout, the channel is still usable."""
    ch_a, ch_b = create_async_channel_pair()

    # First recv times out
    with pytest.raises(RecvTimeout):
        await ch_a.recv(timeout=0.05)

    # Channel should still be open
    assert not ch_a.is_closed

    # Can still send and receive
    await ch_b.send("hello", "world")
    key, data = await ch_a.recv(timeout=1.0)
    assert key == "hello"
    assert data == "world"

# %% nbs/tests/02_rpc/test_exceptions_aio.ipynb 31
@pytest.mark.asyncio
async def test_try_recv_returns_none_not_timeout():
    """AsyncChannel.try_recv() returns None, never raises RecvTimeout."""
    ch_a, ch_b = create_async_channel_pair()

    result = await ch_a.try_recv()
    assert result is None

# %% nbs/tests/02_rpc/test_exceptions_aio.ipynb 34
@pytest.mark.asyncio
async def test_recv_various_timeouts():
    """Test various timeout values."""
    ch_a, ch_b = create_async_channel_pair()

    # Very short timeout
    with pytest.raises(RecvTimeout):
        await ch_a.recv(timeout=0.01)

    # Zero-ish timeout
    with pytest.raises(RecvTimeout):
        await ch_a.recv(timeout=0.001)

# %% nbs/tests/02_rpc/test_exceptions_aio.ipynb 36
@pytest.mark.asyncio
async def test_recv_no_timeout_blocks():
    """AsyncChannel.recv() without timeout blocks until message arrives."""
    ch_a, ch_b = create_async_channel_pair()

    async def delayed_send():
        await asyncio.sleep(0.1)
        await ch_b.send("delayed", "message")

    task = asyncio.create_task(delayed_send())

    start = time.time()
    key, data = await ch_a.recv()  # No timeout
    elapsed = time.time() - start

    await task

    assert key == "delayed"
    assert data == "message"
    assert elapsed >= 0.1

# %% nbs/tests/02_rpc/test_exceptions_aio.ipynb 39
def test_exception_hierarchy():
    """Verify exception hierarchy is correct."""
    assert issubclass(ChannelClosed, RPCError)
    assert issubclass(ChannelBroken, RPCError)
    assert issubclass(RecvTimeout, RPCError)
    assert issubclass(RPCError, Exception)

    # Can catch all with RPCError
    for exc_class in [ChannelClosed, ChannelBroken, RecvTimeout]:
        try:
            raise exc_class("test")
        except RPCError:
            pass  # All should be caught
