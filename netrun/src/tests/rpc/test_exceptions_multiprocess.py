# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/tests/02_rpc/test_exceptions_multiprocess.ipynb

__all__ = ['test_async_multiple_close_is_safe', 'test_async_recv_after_close', 'test_async_recv_shutdown_signal', 'test_async_recv_timeout', 'test_async_recv_timeout_preserves_channel', 'test_async_send_after_close', 'test_async_try_recv_after_close', 'test_async_try_recv_returns_none', 'test_channel_broken_exception_structure', 'test_channel_broken_vs_closed_distinction', 'test_exception_hierarchy', 'test_subprocess_communication', 'test_sync_multiple_close_is_safe', 'test_sync_recv_after_close', 'test_sync_recv_shutdown_signal', 'test_sync_recv_timeout', 'test_sync_recv_timeout_preserves_channel', 'test_sync_send_after_close', 'test_sync_try_recv_after_close', 'test_sync_try_recv_returns_none']

# %% nbs/tests/02_rpc/test_exceptions_multiprocess.ipynb 2
import pytest
import multiprocessing as mp
import time
from netrun.rpc.base import (
    ChannelClosed,
    ChannelBroken,
    RecvTimeout,
    RPCError,
    RPC_KEY_SHUTDOWN,
)
from netrun.rpc.multiprocess import (
    SyncProcessChannel,
    create_queue_pair,
)

# %% nbs/tests/02_rpc/test_exceptions_multiprocess.ipynb 5
def test_sync_send_after_close():
    """SyncProcessChannel.send() raises ChannelClosed after close()."""
    parent_channel, child_queues = create_queue_pair()
    send_q, recv_q = child_queues
    child_channel = SyncProcessChannel(send_q, recv_q)

    child_channel.close()
    assert child_channel.is_closed

    with pytest.raises(ChannelClosed) as exc_info:
        child_channel.send("test", "data")

    assert "closed" in str(exc_info.value).lower()

# %% nbs/tests/02_rpc/test_exceptions_multiprocess.ipynb 7
def test_sync_recv_after_close():
    """SyncProcessChannel.recv() raises ChannelClosed after close()."""
    parent_channel, child_queues = create_queue_pair()
    send_q, recv_q = child_queues
    child_channel = SyncProcessChannel(send_q, recv_q)

    child_channel.close()

    with pytest.raises(ChannelClosed):
        child_channel.recv()

# %% nbs/tests/02_rpc/test_exceptions_multiprocess.ipynb 9
def test_sync_try_recv_after_close():
    """SyncProcessChannel.try_recv() raises ChannelClosed after close()."""
    parent_channel, child_queues = create_queue_pair()
    send_q, recv_q = child_queues
    child_channel = SyncProcessChannel(send_q, recv_q)

    child_channel.close()

    with pytest.raises(ChannelClosed):
        child_channel.try_recv()

# %% nbs/tests/02_rpc/test_exceptions_multiprocess.ipynb 12
@pytest.mark.asyncio
async def test_async_send_after_close():
    """ProcessChannel.send() raises ChannelClosed after close()."""
    parent_channel, _ = create_queue_pair()

    await parent_channel.close()
    assert parent_channel.is_closed

    with pytest.raises(ChannelClosed) as exc_info:
        await parent_channel.send("test", "data")

    assert "closed" in str(exc_info.value).lower()

# %% nbs/tests/02_rpc/test_exceptions_multiprocess.ipynb 14
@pytest.mark.asyncio
async def test_async_recv_after_close():
    """ProcessChannel.recv() raises ChannelClosed after close()."""
    parent_channel, _ = create_queue_pair()

    await parent_channel.close()

    with pytest.raises(ChannelClosed):
        await parent_channel.recv()

# %% nbs/tests/02_rpc/test_exceptions_multiprocess.ipynb 16
@pytest.mark.asyncio
async def test_async_try_recv_after_close():
    """ProcessChannel.try_recv() raises ChannelClosed after close()."""
    parent_channel, _ = create_queue_pair()

    await parent_channel.close()

    with pytest.raises(ChannelClosed):
        await parent_channel.try_recv()

# %% nbs/tests/02_rpc/test_exceptions_multiprocess.ipynb 19
def test_sync_recv_shutdown_signal():
    """SyncProcessChannel.recv() raises ChannelClosed when receiving shutdown signal."""
    parent_channel, child_queues = create_queue_pair()
    send_q, recv_q = child_queues
    child_channel = SyncProcessChannel(send_q, recv_q)

    # Inject shutdown signal
    recv_q.put((RPC_KEY_SHUTDOWN, None))

    with pytest.raises(ChannelClosed) as exc_info:
        child_channel.recv()

    assert "shut down" in str(exc_info.value).lower()
    assert child_channel.is_closed

# %% nbs/tests/02_rpc/test_exceptions_multiprocess.ipynb 21
@pytest.mark.asyncio
async def test_async_recv_shutdown_signal():
    """ProcessChannel.recv() raises ChannelClosed when receiving shutdown signal."""
    parent_channel, child_queues = create_queue_pair()
    send_q, recv_q = child_queues

    # Child sends shutdown to parent
    send_q.put((RPC_KEY_SHUTDOWN, None))

    with pytest.raises(ChannelClosed) as exc_info:
        await parent_channel.recv(timeout=1.0)

    assert "shut down" in str(exc_info.value).lower()
    assert parent_channel.is_closed

# %% nbs/tests/02_rpc/test_exceptions_multiprocess.ipynb 24
def test_sync_multiple_close_is_safe():
    """Multiple close() calls on SyncProcessChannel are safe."""
    parent_channel, child_queues = create_queue_pair()
    send_q, recv_q = child_queues
    child_channel = SyncProcessChannel(send_q, recv_q)

    child_channel.close()
    child_channel.close()
    child_channel.close()

    assert child_channel.is_closed

# %% nbs/tests/02_rpc/test_exceptions_multiprocess.ipynb 26
@pytest.mark.asyncio
async def test_async_multiple_close_is_safe():
    """Multiple close() calls on ProcessChannel are safe."""
    parent_channel, _ = create_queue_pair()

    await parent_channel.close()
    await parent_channel.close()
    await parent_channel.close()

    assert parent_channel.is_closed

# %% nbs/tests/02_rpc/test_exceptions_multiprocess.ipynb 30
def test_sync_recv_timeout():
    """SyncProcessChannel.recv() raises RecvTimeout when timeout expires."""
    parent_channel, child_queues = create_queue_pair()
    send_q, recv_q = child_queues
    child_channel = SyncProcessChannel(send_q, recv_q)

    start = time.time()
    with pytest.raises(RecvTimeout) as exc_info:
        child_channel.recv(timeout=0.1)
    elapsed = time.time() - start

    assert elapsed >= 0.1
    assert elapsed < 0.5
    assert "timed out" in str(exc_info.value).lower()

# %% nbs/tests/02_rpc/test_exceptions_multiprocess.ipynb 32
def test_sync_recv_timeout_preserves_channel():
    """After RecvTimeout, the channel is still usable."""
    parent_channel, child_queues = create_queue_pair()
    send_q, recv_q = child_queues
    child_channel = SyncProcessChannel(send_q, recv_q)

    with pytest.raises(RecvTimeout):
        child_channel.recv(timeout=0.05)

    assert not child_channel.is_closed

    # Can still send
    child_channel.send("still", "works")

    # Can still receive
    recv_q.put(("test", "data"))
    key, data = child_channel.recv(timeout=1.0)
    assert key == "test"

# %% nbs/tests/02_rpc/test_exceptions_multiprocess.ipynb 35
@pytest.mark.asyncio
async def test_async_recv_timeout():
    """ProcessChannel.recv() raises RecvTimeout when timeout expires."""
    parent_channel, _ = create_queue_pair()

    start = time.time()
    with pytest.raises(RecvTimeout) as exc_info:
        await parent_channel.recv(timeout=0.1)
    elapsed = time.time() - start

    assert elapsed >= 0.1
    assert elapsed < 0.5
    assert "timed out" in str(exc_info.value).lower()

# %% nbs/tests/02_rpc/test_exceptions_multiprocess.ipynb 37
@pytest.mark.asyncio
async def test_async_recv_timeout_preserves_channel():
    """After RecvTimeout, the async channel is still usable."""
    parent_channel, child_queues = create_queue_pair()
    send_q, recv_q = child_queues

    with pytest.raises(RecvTimeout):
        await parent_channel.recv(timeout=0.05)

    assert not parent_channel.is_closed

    # Can still send
    await parent_channel.send("hello", "world")
    key, data = recv_q.get(timeout=1.0)
    assert key == "hello"

# %% nbs/tests/02_rpc/test_exceptions_multiprocess.ipynb 40
def test_sync_try_recv_returns_none():
    """SyncProcessChannel.try_recv() returns None, never raises RecvTimeout."""
    parent_channel, child_queues = create_queue_pair()
    send_q, recv_q = child_queues
    child_channel = SyncProcessChannel(send_q, recv_q)

    result = child_channel.try_recv()
    assert result is None

# %% nbs/tests/02_rpc/test_exceptions_multiprocess.ipynb 42
@pytest.mark.asyncio
async def test_async_try_recv_returns_none():
    """ProcessChannel.try_recv() returns None, never raises RecvTimeout."""
    parent_channel, _ = create_queue_pair()

    result = await parent_channel.try_recv()
    assert result is None

# %% nbs/tests/02_rpc/test_exceptions_multiprocess.ipynb 46
def test_channel_broken_exception_structure():
    """ChannelBroken has the expected structure."""
    assert issubclass(ChannelBroken, RPCError)
    assert issubclass(ChannelBroken, Exception)

    exc = ChannelBroken("Pipe broken")
    assert "Pipe broken" in str(exc)

# %% nbs/tests/02_rpc/test_exceptions_multiprocess.ipynb 48
def test_channel_broken_vs_closed_distinction():
    """ChannelBroken and ChannelClosed are distinct exceptions."""
    assert ChannelBroken is not ChannelClosed

    # Catching one doesn't catch the other
    try:
        raise ChannelBroken("broken")
    except ChannelClosed:
        assert False, "ChannelBroken should not be caught by ChannelClosed"
    except ChannelBroken:
        pass

    try:
        raise ChannelClosed("closed")
    except ChannelBroken:
        assert False, "ChannelClosed should not be caught by ChannelBroken"
    except ChannelClosed:
        pass

# %% nbs/tests/02_rpc/test_exceptions_multiprocess.ipynb 51
@pytest.mark.asyncio
async def test_subprocess_communication():
    """Test basic subprocess communication works correctly."""
    import tests.rpc.workers
    # Note: We test the happy path here since forcing ChannelBroken
    # requires actually killing a subprocess which is flaky in tests.
    parent_channel, child_queues = create_queue_pair()

    proc = mp.Process(target=tests.rpc.workers.echo_worker, args=child_queues)
    proc.start()

    # Normal communication
    await parent_channel.send("hello", "world")
    key, data = await parent_channel.recv(timeout=5.0)
    assert key == "echo:hello"
    assert data == "world"

    # Graceful shutdown
    await parent_channel.close()
    proc.join(timeout=2.0)
    if proc.is_alive():
        proc.terminate()
        proc.join(timeout=1.0)

# %% nbs/tests/02_rpc/test_exceptions_multiprocess.ipynb 54
def test_exception_hierarchy():
    """Verify exception hierarchy is correct."""
    assert issubclass(ChannelClosed, RPCError)
    assert issubclass(ChannelBroken, RPCError)
    assert issubclass(RecvTimeout, RPCError)
    assert issubclass(RPCError, Exception)

    for exc_class in [ChannelClosed, ChannelBroken, RecvTimeout]:
        try:
            raise exc_class("test")
        except RPCError:
            pass
