# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/tests/02_rpc/test_exceptions_thread.ipynb

__all__ = ['test_async_multiple_close_is_safe', 'test_async_recv_after_close', 'test_async_recv_no_timeout_blocks', 'test_async_recv_shutdown_signal', 'test_async_recv_timeout', 'test_async_recv_timeout_preserves_channel', 'test_async_send_after_close', 'test_async_try_recv_after_close', 'test_async_try_recv_returns_none_not_timeout', 'test_channel_broken_exception_structure', 'test_channel_broken_vs_closed_distinction', 'test_exception_hierarchy', 'test_parent_close_propagates_to_worker', 'test_sync_multiple_close_is_safe', 'test_sync_recv_after_close', 'test_sync_recv_shutdown_signal', 'test_sync_recv_timeout', 'test_sync_recv_timeout_preserves_channel', 'test_sync_recv_various_timeouts', 'test_sync_send_after_close', 'test_sync_try_recv_after_close', 'test_sync_try_recv_returns_none_not_timeout', 'test_sync_try_recv_shutdown_signal', 'test_worker_close_propagates_to_parent', 'test_worker_exception_handling_pattern']

# %% nbs/tests/02_rpc/test_exceptions_thread.ipynb 2
import pytest
import asyncio
import threading
import time
from netrun.rpc.base import (
    ChannelClosed,
    ChannelBroken,
    RecvTimeout,
    RPC_KEY_SHUTDOWN,
)
from netrun.rpc.thread import (
    ThreadChannel,
    SyncThreadChannel,
    create_thread_channel_pair,
)

# %% nbs/tests/02_rpc/test_exceptions_thread.ipynb 5
def test_sync_send_after_close():
    """SyncThreadChannel.send() raises ChannelClosed after close()."""
    parent_channel, child_queues = create_thread_channel_pair()
    send_q, recv_q = child_queues
    child_channel = SyncThreadChannel(send_q, recv_q)

    # Close the channel
    child_channel.close()
    assert child_channel.is_closed

    # Attempting to send raises ChannelClosed
    with pytest.raises(ChannelClosed) as exc_info:
        child_channel.send("test", "data")

    assert "closed" in str(exc_info.value).lower()

# %% nbs/tests/02_rpc/test_exceptions_thread.ipynb 7
def test_sync_recv_after_close():
    """SyncThreadChannel.recv() raises ChannelClosed after close()."""
    parent_channel, child_queues = create_thread_channel_pair()
    send_q, recv_q = child_queues
    child_channel = SyncThreadChannel(send_q, recv_q)

    child_channel.close()

    with pytest.raises(ChannelClosed):
        child_channel.recv()

# %% nbs/tests/02_rpc/test_exceptions_thread.ipynb 9
def test_sync_try_recv_after_close():
    """SyncThreadChannel.try_recv() raises ChannelClosed after close()."""
    parent_channel, child_queues = create_thread_channel_pair()
    send_q, recv_q = child_queues
    child_channel = SyncThreadChannel(send_q, recv_q)

    child_channel.close()

    with pytest.raises(ChannelClosed):
        child_channel.try_recv()

# %% nbs/tests/02_rpc/test_exceptions_thread.ipynb 12
@pytest.mark.asyncio
async def test_async_send_after_close():
    """ThreadChannel.send() raises ChannelClosed after close()."""
    parent_channel, _ = create_thread_channel_pair()

    await parent_channel.close()
    assert parent_channel.is_closed

    with pytest.raises(ChannelClosed) as exc_info:
        await parent_channel.send("test", "data")

    assert "closed" in str(exc_info.value).lower()

# %% nbs/tests/02_rpc/test_exceptions_thread.ipynb 14
@pytest.mark.asyncio
async def test_async_recv_after_close():
    """ThreadChannel.recv() raises ChannelClosed after close()."""
    parent_channel, _ = create_thread_channel_pair()

    await parent_channel.close()

    with pytest.raises(ChannelClosed):
        await parent_channel.recv()

# %% nbs/tests/02_rpc/test_exceptions_thread.ipynb 16
@pytest.mark.asyncio
async def test_async_try_recv_after_close():
    """ThreadChannel.try_recv() raises ChannelClosed after close()."""
    parent_channel, _ = create_thread_channel_pair()

    await parent_channel.close()

    with pytest.raises(ChannelClosed):
        await parent_channel.try_recv()

# %% nbs/tests/02_rpc/test_exceptions_thread.ipynb 19
def test_sync_recv_shutdown_signal():
    """SyncThreadChannel.recv() raises ChannelClosed when receiving shutdown signal."""
    parent_channel, child_queues = create_thread_channel_pair()
    send_q, recv_q = child_queues
    child_channel = SyncThreadChannel(send_q, recv_q)

    # Manually inject shutdown signal into the queue
    # (This is what happens internally when parent calls close())
    recv_q.put((RPC_KEY_SHUTDOWN, None))

    # Receiving the shutdown signal raises ChannelClosed
    with pytest.raises(ChannelClosed) as exc_info:
        child_channel.recv()

    assert "shut down" in str(exc_info.value).lower()
    assert child_channel.is_closed

# %% nbs/tests/02_rpc/test_exceptions_thread.ipynb 21
def test_sync_try_recv_shutdown_signal():
    """SyncThreadChannel.try_recv() raises ChannelClosed when receiving shutdown signal."""
    parent_channel, child_queues = create_thread_channel_pair()
    send_q, recv_q = child_queues
    child_channel = SyncThreadChannel(send_q, recv_q)

    recv_q.put((RPC_KEY_SHUTDOWN, None))

    with pytest.raises(ChannelClosed):
        child_channel.try_recv()

    assert child_channel.is_closed

# %% nbs/tests/02_rpc/test_exceptions_thread.ipynb 23
@pytest.mark.asyncio
async def test_async_recv_shutdown_signal():
    """ThreadChannel.recv() raises ChannelClosed when receiving shutdown signal."""
    parent_channel, child_queues = create_thread_channel_pair()
    send_q, recv_q = child_queues
    child_channel = SyncThreadChannel(send_q, recv_q)

    # Child sends shutdown to parent
    child_channel._send_queue.put((RPC_KEY_SHUTDOWN, None))

    with pytest.raises(ChannelClosed) as exc_info:
        await parent_channel.recv()

    assert "shut down" in str(exc_info.value).lower()
    assert parent_channel.is_closed

# %% nbs/tests/02_rpc/test_exceptions_thread.ipynb 26
@pytest.mark.asyncio
async def test_parent_close_propagates_to_worker():
    """When parent closes channel, worker's recv() raises ChannelClosed."""
    parent_channel, child_queues = create_thread_channel_pair()
    send_q, recv_q = child_queues
    child_channel = SyncThreadChannel(send_q, recv_q)

    worker_exception = []

    def worker():
        try:
            # This will block until shutdown signal arrives
            child_channel.recv()
        except ChannelClosed as e:
            worker_exception.append(e)

    thread = threading.Thread(target=worker)
    thread.start()

    # Give thread time to start and block on recv
    await asyncio.sleep(0.05)

    # Close from parent side
    await parent_channel.close()

    thread.join(timeout=2.0)

    assert len(worker_exception) == 1
    assert isinstance(worker_exception[0], ChannelClosed)

# %% nbs/tests/02_rpc/test_exceptions_thread.ipynb 28
@pytest.mark.asyncio
async def test_worker_close_propagates_to_parent():
    """When worker closes channel, parent's recv() raises ChannelClosed."""
    parent_channel, child_queues = create_thread_channel_pair()
    send_q, recv_q = child_queues
    child_channel = SyncThreadChannel(send_q, recv_q)

    def worker():
        # Close from worker side
        child_channel.close()

    thread = threading.Thread(target=worker)
    thread.start()
    thread.join(timeout=2.0)

    # Parent should receive the shutdown signal
    with pytest.raises(ChannelClosed):
        await parent_channel.recv(timeout=1.0)

# %% nbs/tests/02_rpc/test_exceptions_thread.ipynb 31
def test_sync_multiple_close_is_safe():
    """Multiple close() calls on SyncThreadChannel are safe."""
    parent_channel, child_queues = create_thread_channel_pair()
    send_q, recv_q = child_queues
    child_channel = SyncThreadChannel(send_q, recv_q)

    # First close
    child_channel.close()
    assert child_channel.is_closed

    # Second close - should not raise
    child_channel.close()
    assert child_channel.is_closed

    # Third close - still safe
    child_channel.close()

# %% nbs/tests/02_rpc/test_exceptions_thread.ipynb 33
@pytest.mark.asyncio
async def test_async_multiple_close_is_safe():
    """Multiple close() calls on ThreadChannel are safe."""
    parent_channel, _ = create_thread_channel_pair()

    await parent_channel.close()
    await parent_channel.close()
    await parent_channel.close()

    assert parent_channel.is_closed

# %% nbs/tests/02_rpc/test_exceptions_thread.ipynb 37
def test_sync_recv_timeout():
    """SyncThreadChannel.recv() raises RecvTimeout when timeout expires."""
    parent_channel, child_queues = create_thread_channel_pair()
    send_q, recv_q = child_queues
    child_channel = SyncThreadChannel(send_q, recv_q)

    start = time.time()
    with pytest.raises(RecvTimeout) as exc_info:
        child_channel.recv(timeout=0.1)
    elapsed = time.time() - start

    # Should have waited approximately the timeout duration
    assert elapsed >= 0.1
    assert elapsed < 0.5  # But not too long
    assert "timed out" in str(exc_info.value).lower()

# %% nbs/tests/02_rpc/test_exceptions_thread.ipynb 39
def test_sync_recv_timeout_preserves_channel():
    """After RecvTimeout, the channel is still usable."""
    parent_channel, child_queues = create_thread_channel_pair()
    send_q, recv_q = child_queues
    child_channel = SyncThreadChannel(send_q, recv_q)

    # First recv times out
    with pytest.raises(RecvTimeout):
        child_channel.recv(timeout=0.05)

    # Channel should still be open
    assert not child_channel.is_closed

    # Can still send
    child_channel.send("still", "works")

    # Can still receive (if message is available)
    recv_q.put(("test", "data"))
    key, data = child_channel.recv(timeout=1.0)
    assert key == "test"
    assert data == "data"

# %% nbs/tests/02_rpc/test_exceptions_thread.ipynb 42
@pytest.mark.asyncio
async def test_async_recv_timeout():
    """ThreadChannel.recv() raises RecvTimeout when timeout expires."""
    parent_channel, _ = create_thread_channel_pair()

    start = time.time()
    with pytest.raises(RecvTimeout) as exc_info:
        await parent_channel.recv(timeout=0.1)
    elapsed = time.time() - start

    assert elapsed >= 0.1
    assert elapsed < 0.5
    assert "timed out" in str(exc_info.value).lower()

# %% nbs/tests/02_rpc/test_exceptions_thread.ipynb 44
@pytest.mark.asyncio
async def test_async_recv_timeout_preserves_channel():
    """After RecvTimeout, the async channel is still usable."""
    parent_channel, child_queues = create_thread_channel_pair()
    send_q, recv_q = child_queues
    child_channel = SyncThreadChannel(send_q, recv_q)

    # First recv times out
    with pytest.raises(RecvTimeout):
        await parent_channel.recv(timeout=0.05)

    # Channel should still be open
    assert not parent_channel.is_closed

    # Can still send and receive
    await parent_channel.send("hello", "world")
    key, data = child_channel.recv(timeout=1.0)
    assert key == "hello"

# %% nbs/tests/02_rpc/test_exceptions_thread.ipynb 47
def test_sync_try_recv_returns_none_not_timeout():
    """SyncThreadChannel.try_recv() returns None, never raises RecvTimeout."""
    parent_channel, child_queues = create_thread_channel_pair()
    send_q, recv_q = child_queues
    child_channel = SyncThreadChannel(send_q, recv_q)

    # Should return None immediately, not raise
    result = child_channel.try_recv()
    assert result is None

# %% nbs/tests/02_rpc/test_exceptions_thread.ipynb 49
@pytest.mark.asyncio
async def test_async_try_recv_returns_none_not_timeout():
    """ThreadChannel.try_recv() returns None, never raises RecvTimeout."""
    parent_channel, _ = create_thread_channel_pair()

    result = await parent_channel.try_recv()
    assert result is None

# %% nbs/tests/02_rpc/test_exceptions_thread.ipynb 52
def test_sync_recv_various_timeouts():
    """Test various timeout values for SyncThreadChannel.recv()."""
    parent_channel, child_queues = create_thread_channel_pair()
    send_q, recv_q = child_queues
    child_channel = SyncThreadChannel(send_q, recv_q)

    # Very short timeout
    with pytest.raises(RecvTimeout):
        child_channel.recv(timeout=0.01)

    # Zero timeout - should timeout immediately
    with pytest.raises(RecvTimeout):
        child_channel.recv(timeout=0.001)

# %% nbs/tests/02_rpc/test_exceptions_thread.ipynb 54
@pytest.mark.asyncio
async def test_async_recv_no_timeout_blocks():
    """ThreadChannel.recv() without timeout blocks until message arrives."""
    parent_channel, child_queues = create_thread_channel_pair()
    send_q, recv_q = child_queues
    child_channel = SyncThreadChannel(send_q, recv_q)

    # Send a message after a delay
    def delayed_send():
        time.sleep(0.1)
        child_channel.send("delayed", "message")

    thread = threading.Thread(target=delayed_send)
    thread.start()

    # This should block until the message arrives (no timeout)
    start = time.time()
    key, data = await parent_channel.recv()  # No timeout = blocks indefinitely
    elapsed = time.time() - start

    thread.join()

    assert key == "delayed"
    assert data == "message"
    assert elapsed >= 0.1  # Should have waited for the delayed send

# %% nbs/tests/02_rpc/test_exceptions_thread.ipynb 58
def test_channel_broken_exception_structure():
    """ChannelBroken has the expected structure."""
    from netrun.rpc.base import ChannelBroken, RPCError

    # ChannelBroken is an RPCError
    assert issubclass(ChannelBroken, RPCError)
    assert issubclass(ChannelBroken, Exception)

    # Can be raised with a message
    exc = ChannelBroken("Connection lost unexpectedly")
    assert "Connection lost" in str(exc)

# %% nbs/tests/02_rpc/test_exceptions_thread.ipynb 60
def test_channel_broken_vs_closed_distinction():
    """ChannelBroken and ChannelClosed are distinct exceptions."""
    from netrun.rpc.base import ChannelBroken, ChannelClosed

    # They are different exception types
    assert ChannelBroken is not ChannelClosed

    # Catching one doesn't catch the other
    try:
        raise ChannelBroken("broken")
    except ChannelClosed:
        assert False, "ChannelBroken should not be caught by ChannelClosed"
    except ChannelBroken:
        pass  # Expected

    try:
        raise ChannelClosed("closed")
    except ChannelBroken:
        assert False, "ChannelClosed should not be caught by ChannelBroken"
    except ChannelClosed:
        pass  # Expected

# %% nbs/tests/02_rpc/test_exceptions_thread.ipynb 63
@pytest.mark.asyncio
async def test_worker_exception_handling_pattern():
    """Demonstrate proper exception handling pattern for workers."""
    from netrun.rpc.base import ChannelBroken

    parent_channel, child_queues = create_thread_channel_pair()
    send_q, recv_q = child_queues
    child_channel = SyncThreadChannel(send_q, recv_q)

    worker_status = {"shutdown_reason": None}

    def robust_worker():
        """Worker that handles all exception types properly."""
        try:
            while True:
                key, data = child_channel.recv()
                child_channel.send(f"echo:{key}", data)
        except ChannelClosed:
            worker_status["shutdown_reason"] = "graceful"
        except ChannelBroken as e:
            worker_status["shutdown_reason"] = f"broken: {e}"
        except Exception as e:
            worker_status["shutdown_reason"] = f"unexpected: {e}"

    thread = threading.Thread(target=robust_worker)
    thread.start()

    # Normal operation
    await parent_channel.send("hello", "world")
    key, data = await parent_channel.recv(timeout=1.0)
    assert key == "echo:hello"

    # Graceful shutdown
    await parent_channel.close()
    thread.join(timeout=2.0)

    assert worker_status["shutdown_reason"] == "graceful"

# %% nbs/tests/02_rpc/test_exceptions_thread.ipynb 66
def test_exception_hierarchy():
    """Verify exception hierarchy is correct."""
    from netrun.rpc.base import RPCError, ChannelClosed, ChannelBroken, RecvTimeout

    # All are RPCErrors
    assert issubclass(ChannelClosed, RPCError)
    assert issubclass(ChannelBroken, RPCError)
    assert issubclass(RecvTimeout, RPCError)

    # RPCError is an Exception
    assert issubclass(RPCError, Exception)

    # Can catch all with RPCError
    for exc_class in [ChannelClosed, ChannelBroken, RecvTimeout]:
        try:
            raise exc_class("test")
        except RPCError:
            pass  # All should be caught
