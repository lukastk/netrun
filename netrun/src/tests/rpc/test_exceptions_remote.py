# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/tests/02_rpc/test_exceptions_remote.ipynb

__all__ = ['test_channel_broken_exception_structure', 'test_channel_broken_vs_closed_distinction', 'test_connection_error_no_server', 'test_exception_hierarchy', 'test_multiple_close_is_safe', 'test_recv_after_close', 'test_recv_shutdown_from_server', 'test_recv_timeout', 'test_recv_timeout_preserves_channel', 'test_send_after_close', 'test_server_receives_client_close', 'test_try_recv_after_close', 'test_try_recv_returns_none']

# %% nbs/tests/02_rpc/test_exceptions_remote.ipynb 2
import pytest
import asyncio
import time
from netrun.rpc.base import (
    ChannelClosed,
    ChannelBroken,
    RecvTimeout,
    RPCError,
    RPC_KEY_SHUTDOWN,
)
from netrun.rpc.remote import (
    WebSocketChannel,
    connect,
    serve_background,
)

# %% nbs/tests/02_rpc/test_exceptions_remote.ipynb 5
@pytest.mark.asyncio
async def test_send_after_close():
    """WebSocketChannel.send() raises ChannelClosed after close()."""
    async def handler(channel):
        await asyncio.sleep(10)  # Keep server alive

    async with serve_background(handler, "127.0.0.1", 29801):
        async with connect("ws://127.0.0.1:29801") as channel:
            await channel.close()
            assert channel.is_closed

            with pytest.raises(ChannelClosed) as exc_info:
                await channel.send("test", "data")

            assert "closed" in str(exc_info.value).lower()

# %% nbs/tests/02_rpc/test_exceptions_remote.ipynb 7
@pytest.mark.asyncio
async def test_recv_after_close():
    """WebSocketChannel.recv() raises ChannelClosed after close() and queue empty."""
    async def handler(channel):
        await asyncio.sleep(10)

    async with serve_background(handler, "127.0.0.1", 29802):
        async with connect("ws://127.0.0.1:29802") as channel:
            await channel.close()

            # After close with empty queue, should raise
            with pytest.raises(ChannelClosed):
                await channel.recv(timeout=0.1)

# %% nbs/tests/02_rpc/test_exceptions_remote.ipynb 9
@pytest.mark.asyncio
async def test_try_recv_after_close():
    """WebSocketChannel.try_recv() raises ChannelClosed after close() and queue empty."""
    async def handler(channel):
        await asyncio.sleep(10)

    async with serve_background(handler, "127.0.0.1", 29803):
        async with connect("ws://127.0.0.1:29803") as channel:
            await channel.close()

            with pytest.raises(ChannelClosed):
                await channel.try_recv()

# %% nbs/tests/02_rpc/test_exceptions_remote.ipynb 12
@pytest.mark.asyncio
async def test_recv_shutdown_from_server():
    """Client's recv() raises ChannelClosed when server closes."""
    async def handler(channel):
        # Immediately close
        await channel.close()

    async with serve_background(handler, "127.0.0.1", 29804):
        async with connect("ws://127.0.0.1:29804") as channel:
            # Server closed, so recv should get shutdown signal
            with pytest.raises(ChannelClosed):
                await channel.recv(timeout=1.0)

# %% nbs/tests/02_rpc/test_exceptions_remote.ipynb 14
@pytest.mark.asyncio
async def test_server_receives_client_close():
    """Server's recv() raises ChannelClosed when client closes."""
    server_exception = []

    async def handler(channel):
        try:
            await channel.recv(timeout=2.0)
        except ChannelClosed as e:
            server_exception.append(e)

    async with serve_background(handler, "127.0.0.1", 29805):
        async with connect("ws://127.0.0.1:29805") as channel:
            # Client closes immediately
            pass  # Context manager will close

        await asyncio.sleep(0.1)  # Let server process

    assert len(server_exception) == 1
    assert isinstance(server_exception[0], ChannelClosed)

# %% nbs/tests/02_rpc/test_exceptions_remote.ipynb 17
@pytest.mark.asyncio
async def test_multiple_close_is_safe():
    """Multiple close() calls are safe."""
    async def handler(channel):
        await asyncio.sleep(10)

    async with serve_background(handler, "127.0.0.1", 29806):
        async with connect("ws://127.0.0.1:29806") as channel:
            await channel.close()
            await channel.close()
            await channel.close()

            assert channel.is_closed

# %% nbs/tests/02_rpc/test_exceptions_remote.ipynb 21
@pytest.mark.asyncio
async def test_recv_timeout():
    """WebSocketChannel.recv() raises RecvTimeout when timeout expires."""
    async def handler(channel):
        await asyncio.sleep(10)  # Don't send anything

    async with serve_background(handler, "127.0.0.1", 29807):
        async with connect("ws://127.0.0.1:29807") as channel:
            start = time.time()
            with pytest.raises(RecvTimeout) as exc_info:
                await channel.recv(timeout=0.1)
            elapsed = time.time() - start

            assert elapsed >= 0.1
            assert elapsed < 0.5
            assert "timed out" in str(exc_info.value).lower()

# %% nbs/tests/02_rpc/test_exceptions_remote.ipynb 23
@pytest.mark.asyncio
async def test_recv_timeout_preserves_channel():
    """After RecvTimeout, the channel is still usable."""
    async def handler(channel):
        # Wait a bit, then respond
        await asyncio.sleep(0.15)
        await channel.send("delayed", "response")

    async with serve_background(handler, "127.0.0.1", 29808):
        async with connect("ws://127.0.0.1:29808") as channel:
            # First recv times out
            with pytest.raises(RecvTimeout):
                await channel.recv(timeout=0.05)

            # Channel still usable
            assert not channel.is_closed

            # Can receive the delayed message
            key, data = await channel.recv(timeout=1.0)
            assert key == "delayed"
            assert data == "response"

# %% nbs/tests/02_rpc/test_exceptions_remote.ipynb 26
@pytest.mark.asyncio
async def test_try_recv_returns_none():
    """WebSocketChannel.try_recv() returns None, never raises RecvTimeout."""
    async def handler(channel):
        await asyncio.sleep(10)

    async with serve_background(handler, "127.0.0.1", 29809):
        async with connect("ws://127.0.0.1:29809") as channel:
            # Start receiver to enable try_recv
            await channel._start_receiver()
            await asyncio.sleep(0.01)

            result = await channel.try_recv()
            assert result is None

# %% nbs/tests/02_rpc/test_exceptions_remote.ipynb 30
def test_channel_broken_exception_structure():
    """ChannelBroken has the expected structure."""
    assert issubclass(ChannelBroken, RPCError)
    assert issubclass(ChannelBroken, Exception)

    exc = ChannelBroken("Connection lost")
    assert "Connection lost" in str(exc)

# %% nbs/tests/02_rpc/test_exceptions_remote.ipynb 32
def test_channel_broken_vs_closed_distinction():
    """ChannelBroken and ChannelClosed are distinct exceptions."""
    assert ChannelBroken is not ChannelClosed

    try:
        raise ChannelBroken("broken")
    except ChannelClosed:
        assert False, "ChannelBroken should not be caught by ChannelClosed"
    except ChannelBroken:
        pass

    try:
        raise ChannelClosed("closed")
    except ChannelBroken:
        assert False, "ChannelClosed should not be caught by ChannelBroken"
    except ChannelClosed:
        pass

# %% nbs/tests/02_rpc/test_exceptions_remote.ipynb 35
@pytest.mark.asyncio
async def test_connection_error_no_server():
    """connect() raises ConnectionError when server is not available."""
    with pytest.raises(ConnectionError) as exc_info:
        async with connect("ws://127.0.0.1:29899"):  # No server on this port
            pass

    assert "Failed to connect" in str(exc_info.value)

# %% nbs/tests/02_rpc/test_exceptions_remote.ipynb 38
def test_exception_hierarchy():
    """Verify exception hierarchy is correct."""
    assert issubclass(ChannelClosed, RPCError)
    assert issubclass(ChannelBroken, RPCError)
    assert issubclass(RecvTimeout, RPCError)
    assert issubclass(RPCError, Exception)

    for exc_class in [ChannelClosed, ChannelBroken, RecvTimeout]:
        try:
            raise exc_class("test")
        except RPCError:
            pass
