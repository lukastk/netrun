# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/tests/03_pool/test_exceptions_thread.ipynb

__all__ = ['crash_after_one_worker', 'echo_worker', 'immediate_exit_worker', 'raising_worker', 'test_broadcast_before_start', 'test_close_allows_restart', 'test_exception_hierarchy', 'test_recv_before_start', 'test_recv_timeout', 'test_recv_timeout_preserves_pool', 'test_send_before_start', 'test_send_invalid_worker_id_negative', 'test_send_invalid_worker_id_too_large', 'test_start_twice', 'test_try_recv_before_start', 'test_try_recv_returns_none', 'test_worker_crash_detected', 'test_worker_crashed_exception_structure', 'test_worker_exception', 'test_worker_exception_dict_form', 'test_worker_exception_structure']

# %% nbs/tests/03_pool/test_exceptions_thread.ipynb 2
import pytest
import asyncio
import time
from netrun.rpc.base import ChannelClosed, RecvTimeout
from netrun.pool.base import (
    PoolError,
    PoolNotStarted,
    PoolAlreadyStarted,
    WorkerException,
    WorkerCrashed,
)
from netrun.pool.thread import ThreadPool

# %% nbs/tests/03_pool/test_exceptions_thread.ipynb 4
def echo_worker(channel, worker_id):
    """Echo worker for testing."""
    try:
        while True:
            key, data = channel.recv()
            channel.send(f"echo:{key}", {"worker_id": worker_id, "data": data})
    except ChannelClosed:
        pass

# %% nbs/tests/03_pool/test_exceptions_thread.ipynb 5
def raising_worker(channel, worker_id):
    """Worker that raises an exception on specific message."""
    try:
        while True:
            key, data = channel.recv()
            if key == "raise":
                raise ValueError(f"Intentional error: {data}")
            channel.send("ok", data)
    except ChannelClosed:
        pass

# %% nbs/tests/03_pool/test_exceptions_thread.ipynb 6
def immediate_exit_worker(channel, worker_id):
    """Worker that exits immediately without processing."""
    return  # Exit immediately

# %% nbs/tests/03_pool/test_exceptions_thread.ipynb 7
def crash_after_one_worker(channel, worker_id):
    """Worker that processes one message then crashes."""
    try:
        key, data = channel.recv()
        channel.send("got", data)
        # Simulate crash by raising uncaught exception
        raise RuntimeError("Simulated crash")
    except ChannelClosed:
        pass

# %% nbs/tests/03_pool/test_exceptions_thread.ipynb 10
@pytest.mark.asyncio
async def test_send_before_start():
    """ThreadPool.send() raises PoolNotStarted before start()."""
    pool = ThreadPool(echo_worker, num_workers=2)

    with pytest.raises(PoolNotStarted) as exc_info:
        await pool.send(0, "hello", "world")

    assert "not been started" in str(exc_info.value).lower()

# %% nbs/tests/03_pool/test_exceptions_thread.ipynb 12
@pytest.mark.asyncio
async def test_recv_before_start():
    """ThreadPool.recv() raises PoolNotStarted before start()."""
    pool = ThreadPool(echo_worker, num_workers=2)

    with pytest.raises(PoolNotStarted):
        await pool.recv(timeout=0.1)

# %% nbs/tests/03_pool/test_exceptions_thread.ipynb 14
@pytest.mark.asyncio
async def test_try_recv_before_start():
    """ThreadPool.try_recv() raises PoolNotStarted before start()."""
    pool = ThreadPool(echo_worker, num_workers=2)

    with pytest.raises(PoolNotStarted):
        await pool.try_recv()

# %% nbs/tests/03_pool/test_exceptions_thread.ipynb 16
@pytest.mark.asyncio
async def test_broadcast_before_start():
    """ThreadPool.broadcast() raises PoolNotStarted before start()."""
    pool = ThreadPool(echo_worker, num_workers=2)

    with pytest.raises(PoolNotStarted):
        await pool.broadcast("hello", "world")

# %% nbs/tests/03_pool/test_exceptions_thread.ipynb 19
@pytest.mark.asyncio
async def test_start_twice():
    """ThreadPool.start() raises PoolAlreadyStarted if already running."""
    pool = ThreadPool(echo_worker, num_workers=2)

    await pool.start()
    try:
        assert pool.is_running

        with pytest.raises(PoolAlreadyStarted) as exc_info:
            await pool.start()

        assert "already running" in str(exc_info.value).lower()
    finally:
        await pool.close()

# %% nbs/tests/03_pool/test_exceptions_thread.ipynb 21
@pytest.mark.asyncio
async def test_close_allows_restart():
    """After close(), the pool can be started again."""
    pool = ThreadPool(echo_worker, num_workers=2)

    # First start
    await pool.start()
    await pool.close()
    assert not pool.is_running

    # Second start should work
    await pool.start()
    assert pool.is_running
    await pool.close()

# %% nbs/tests/03_pool/test_exceptions_thread.ipynb 25
@pytest.mark.asyncio
async def test_recv_timeout():
    """ThreadPool.recv() raises RecvTimeout when timeout expires."""
    pool = ThreadPool(echo_worker, num_workers=2)
    await pool.start()

    try:
        start = time.time()
        with pytest.raises(RecvTimeout) as exc_info:
            await pool.recv(timeout=0.1)
        elapsed = time.time() - start

        assert elapsed >= 0.1
        assert elapsed < 0.5
        assert "timed out" in str(exc_info.value).lower()
    finally:
        await pool.close()

# %% nbs/tests/03_pool/test_exceptions_thread.ipynb 27
@pytest.mark.asyncio
async def test_recv_timeout_preserves_pool():
    """After RecvTimeout, the pool is still usable."""
    pool = ThreadPool(echo_worker, num_workers=2)
    await pool.start()

    try:
        # First recv times out
        with pytest.raises(RecvTimeout):
            await pool.recv(timeout=0.05)

        # Pool should still be running
        assert pool.is_running

        # Can still send and receive
        await pool.send(0, "hello", "world")
        msg = await pool.recv(timeout=1.0)
        assert msg.key == "echo:hello"
        assert msg.data["data"] == "world"
    finally:
        await pool.close()

# %% nbs/tests/03_pool/test_exceptions_thread.ipynb 30
@pytest.mark.asyncio
async def test_try_recv_returns_none():
    """ThreadPool.try_recv() returns None, never raises RecvTimeout."""
    pool = ThreadPool(echo_worker, num_workers=2)
    await pool.start()

    try:
        result = await pool.try_recv()
        assert result is None
    finally:
        await pool.close()

# %% nbs/tests/03_pool/test_exceptions_thread.ipynb 33
@pytest.mark.asyncio
async def test_worker_exception():
    """WorkerException is raised when worker raises an exception."""
    pool = ThreadPool(raising_worker, num_workers=1)
    await pool.start()

    try:
        await pool.send(0, "raise", "test error")

        # Worker exception and crash detection can race - accept either
        with pytest.raises((WorkerException, WorkerCrashed)) as exc_info:
            await pool.recv(timeout=2.0)

        exc = exc_info.value
        assert exc.worker_id == 0

        if isinstance(exc, WorkerException):
            assert isinstance(exc.original_exception, ValueError)
            assert "Intentional error" in str(exc.original_exception)
    finally:
        await pool.close()

# %% nbs/tests/03_pool/test_exceptions_thread.ipynb 35
@pytest.mark.asyncio
async def test_worker_exception_structure():
    """WorkerException has the expected structure."""
    exc = WorkerException(42, ValueError("test"))

    assert exc.worker_id == 42
    assert isinstance(exc.original_exception, ValueError)
    assert "Worker 42" in str(exc)
    assert "ValueError" in str(exc)
    assert "test" in str(exc)

# %% nbs/tests/03_pool/test_exceptions_thread.ipynb 37
@pytest.mark.asyncio
async def test_worker_exception_dict_form():
    """WorkerException can also hold error dict (for unpickleable exceptions)."""
    error_dict = {
        "type": "CustomError",
        "message": "Something went wrong",
    }
    exc = WorkerException(0, error_dict)

    assert exc.worker_id == 0
    assert exc.original_exception == error_dict
    assert "CustomError" in str(exc)
    assert "Something went wrong" in str(exc)

# %% nbs/tests/03_pool/test_exceptions_thread.ipynb 40
@pytest.mark.asyncio
async def test_worker_crashed_exception_structure():
    """WorkerCrashed has the expected structure."""
    details = {"reason": "Thread exited unexpectedly", "exit_code": 1}
    exc = WorkerCrashed(5, details)

    assert exc.worker_id == 5
    assert exc.details == details
    assert "Worker 5" in str(exc)
    assert "crashed" in str(exc).lower()

# %% nbs/tests/03_pool/test_exceptions_thread.ipynb 42
@pytest.mark.asyncio
async def test_worker_crash_detected():
    """When a worker thread exits unexpectedly, WorkerCrashed is raised."""
    pool = ThreadPool(immediate_exit_worker, num_workers=1)
    await pool.start()

    try:
        # Worker exits immediately
        # The monitor task should detect it and send crash notification
        await asyncio.sleep(1.0)  # Wait for monitor to detect

        with pytest.raises(WorkerCrashed) as exc_info:
            await pool.recv(timeout=1.0)

        assert exc_info.value.worker_id == 0
        assert "unexpectedly" in str(exc_info.value).lower()
    finally:
        await pool.close()

# %% nbs/tests/03_pool/test_exceptions_thread.ipynb 45
@pytest.mark.asyncio
async def test_send_invalid_worker_id_negative():
    """send() raises ValueError for negative worker_id."""
    pool = ThreadPool(echo_worker, num_workers=3)
    await pool.start()

    try:
        with pytest.raises(ValueError) as exc_info:
            await pool.send(-1, "hello", "world")

        assert "out of range" in str(exc_info.value)
    finally:
        await pool.close()

# %% nbs/tests/03_pool/test_exceptions_thread.ipynb 47
@pytest.mark.asyncio
async def test_send_invalid_worker_id_too_large():
    """send() raises ValueError for worker_id >= num_workers."""
    pool = ThreadPool(echo_worker, num_workers=3)
    await pool.start()

    try:
        with pytest.raises(ValueError) as exc_info:
            await pool.send(3, "hello", "world")  # Valid are 0, 1, 2

        assert "out of range" in str(exc_info.value)

        with pytest.raises(ValueError):
            await pool.send(100, "hello", "world")
    finally:
        await pool.close()

# %% nbs/tests/03_pool/test_exceptions_thread.ipynb 50
def test_exception_hierarchy():
    """Verify exception hierarchy is correct."""
    assert issubclass(PoolNotStarted, PoolError)
    assert issubclass(PoolAlreadyStarted, PoolError)
    assert issubclass(WorkerException, PoolError)
    assert issubclass(WorkerCrashed, PoolError)
    assert issubclass(PoolError, Exception)

    # Can catch all pool errors with PoolError
    for exc_class in [PoolNotStarted, PoolAlreadyStarted]:
        try:
            raise exc_class("test")
        except PoolError:
            pass  # All should be caught
