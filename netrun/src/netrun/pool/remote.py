# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/netrun/03_pool/03_remote.ipynb

__all__ = ['MSG_BROADCAST', 'MSG_CLOSE', 'MSG_CREATE_POOL', 'MSG_ERROR', 'MSG_POOL_CREATED', 'MSG_RECV', 'MSG_SEND', 'RemotePoolClient', 'RemotePoolServer']

# %% nbs/netrun/03_pool/03_remote.ipynb 3
import asyncio
from contextlib import asynccontextmanager
from typing import Any

from ..pool.base import (
    PoolError,
    PoolNotStarted,
    WorkerFn,
    WorkerId,
    WorkerMessage,
)
from ..pool.multiprocess import MultiprocessPool
from ..rpc.base import ChannelClosed, RecvTimeout
from ..rpc.remote import (
    WebSocketChannel,
    serve_background,
)

# %% nbs/netrun/03_pool/03_remote.ipynb 5
# Message types
MSG_CREATE_POOL = "create_pool"
MSG_POOL_CREATED = "pool_created"
MSG_SEND = "send"
MSG_RECV = "recv"
MSG_BROADCAST = "broadcast"
MSG_CLOSE = "close"
MSG_ERROR = "error"

# %% nbs/netrun/03_pool/03_remote.ipynb 7
class RemotePoolServer:
    """Server that hosts remote worker pools.

    Clients connect, request a pool configuration, and the server
    creates a MultiprocessPool to handle their requests.
    """

    def __init__(self):
        """Create a remote pool server."""
        self._workers: dict[str, WorkerFn] = {}
        self._running = False

    def register_worker(self, name: str, worker_fn: WorkerFn) -> None:
        """Register a worker function by name.

        Args:
            name: Name clients will use to request this worker
            worker_fn: The worker function (must be importable for multiprocessing)
        """
        self._workers[name] = worker_fn

    @property
    def registered_workers(self) -> list[str]:
        """List of registered worker names."""
        return list(self._workers.keys())

    async def serve(self, host: str = "0.0.0.0", port: int = 8080) -> None:
        """Start the server and handle connections.

        This blocks until the server is stopped.

        Args:
            host: Host to bind to
            port: Port to listen on
        """
        from ..rpc.remote import serve

        async def handle_client(channel: WebSocketChannel):
            await self._handle_client(channel)

        await serve(handle_client, host, port)

    @asynccontextmanager
    async def serve_background(self, host: str = "0.0.0.0", port: int = 8080):
        """Start the server in the background.

        Args:
            host: Host to bind to
            port: Port to listen on

        Yields:
            The server object
        """
        async def handle_client(channel: WebSocketChannel):
            await self._handle_client(channel)

        async with serve_background(handle_client, host, port) as server:
            yield server

    async def _handle_client(self, channel: WebSocketChannel) -> None:
        """Handle a single client connection."""
        pool: MultiprocessPool | None = None

        try:
            while True:
                key, data = await channel.recv()

                if key == MSG_CREATE_POOL:
                    # Create pool
                    worker_name = data["worker_name"]
                    num_processes = data["num_processes"]
                    threads_per_process = data.get("threads_per_process", 1)

                    if worker_name not in self._workers:
                        await channel.send(MSG_ERROR, f"Unknown worker: {worker_name}")
                        continue

                    if pool is not None:
                        await pool.close()

                    pool = MultiprocessPool(
                        worker_fn=self._workers[worker_name],
                        num_processes=num_processes,
                        threads_per_process=threads_per_process,
                    )
                    await pool.start()

                    await channel.send(MSG_POOL_CREATED, {
                        "num_workers": pool.num_workers,
                        "num_processes": pool.num_processes,
                        "threads_per_process": pool.threads_per_process,
                    })

                    # Start forwarding responses from pool to client
                    asyncio.create_task(self._forward_responses(pool, channel))

                elif key == MSG_SEND:
                    if pool is None:
                        await channel.send(MSG_ERROR, "No pool created")
                        continue

                    worker_id = data["worker_id"]
                    msg_key = data["key"]
                    msg_data = data["data"]
                    await pool.send(worker_id, msg_key, msg_data)

                elif key == MSG_BROADCAST:
                    if pool is None:
                        await channel.send(MSG_ERROR, "No pool created")
                        continue

                    msg_key = data["key"]
                    msg_data = data["data"]
                    await pool.broadcast(msg_key, msg_data)

                elif key == MSG_CLOSE:
                    break

        except ChannelClosed:
            pass
        finally:
            if pool is not None:
                await pool.close()

    async def _forward_responses(self, pool: MultiprocessPool, channel: WebSocketChannel) -> None:
        """Forward responses from pool workers to the client."""
        try:
            while pool.is_running and not channel.is_closed:
                try:
                    msg = await pool.recv(timeout=None)
                    await channel.send(MSG_RECV, {
                        "worker_id": msg.worker_id,
                        "key": msg.key,
                        "data": msg.data,
                    })
                except RecvTimeout:
                    continue
                except ChannelClosed:
                    break
        except Exception:
            pass

# %% nbs/netrun/03_pool/03_remote.ipynb 9
class RemotePoolClient:
    """Client for connecting to a remote pool server.

    Provides the same interface as local pools (send, recv, etc.)
    but workers run on the remote server.
    """

    def __init__(self, url: str):
        """Create a client.

        Args:
            url: WebSocket URL of the server (e.g., "ws://server:8080")
        """
        self._url = url
        self._channel: WebSocketChannel | None = None
        self._num_workers = 0
        self._num_processes = 0
        self._threads_per_process = 0
        self._running = False
        self._recv_queue: asyncio.Queue = asyncio.Queue()
        self._recv_task: asyncio.Task | None = None

    @property
    def num_workers(self) -> int:
        """Total number of workers in the remote pool."""
        return self._num_workers

    @property
    def num_processes(self) -> int:
        """Number of processes on the server."""
        return self._num_processes

    @property
    def threads_per_process(self) -> int:
        """Number of threads per process."""
        return self._threads_per_process

    @property
    def is_running(self) -> bool:
        """Whether the client is connected and pool is created."""
        return self._running

    async def connect(self) -> None:
        """Connect to the server."""
        from ..rpc.remote import connect_channel
        self._channel = await connect_channel(self._url)

    async def create_pool(
        self,
        worker_name: str,
        num_processes: int,
        threads_per_process: int = 1,
    ) -> None:
        """Create a pool on the server.

        Args:
            worker_name: Name of registered worker function on server
            num_processes: Number of processes
            threads_per_process: Threads per process
        """
        if self._channel is None:
            raise PoolNotStarted("Not connected to server")

        await self._channel.send(MSG_CREATE_POOL, {
            "worker_name": worker_name,
            "num_processes": num_processes,
            "threads_per_process": threads_per_process,
        })

        # Wait for response
        key, data = await self._channel.recv(timeout=None)

        if key == MSG_ERROR:
            raise PoolError(f"Server error: {data}")

        if key != MSG_POOL_CREATED:
            raise PoolError(f"Unexpected response: {key}")

        self._num_workers = data["num_workers"]
        self._num_processes = data["num_processes"]
        self._threads_per_process = data["threads_per_process"]
        self._running = True

        # Start receiving messages from server
        self._recv_task = asyncio.create_task(self._receive_loop())

    async def _receive_loop(self) -> None:
        """Receive messages from server and queue them."""
        try:
            while self._running and self._channel and not self._channel.is_closed:
                try:
                    key, data = await self._channel.recv(timeout=None)
                    if key == MSG_RECV:
                        await self._recv_queue.put(data)
                    elif key == MSG_ERROR:
                        print(f"Server error: {data}")
                except RecvTimeout:
                    continue
                except ChannelClosed:
                    break
        except Exception:
            pass

    async def close(self, timeout: float | None = None) -> None:
        """Close the connection and remote pool.

        Args:
            timeout: Not used for RemotePoolClient (included for protocol compatibility).
        """
        self._running = False

        if self._recv_task and not self._recv_task.done():
            self._recv_task.cancel()
            try:
                await self._recv_task
            except asyncio.CancelledError:
                pass

        if self._channel and not self._channel.is_closed:
            try:
                await self._channel.send(MSG_CLOSE, None)
            except Exception:
                pass
            await self._channel.close()

        self._channel = None

    async def send(self, worker_id: WorkerId, key: str, data: Any) -> None:
        """Send a message to a specific worker on the server."""
        if not self._running or self._channel is None:
            raise PoolNotStarted("Pool not created")

        if worker_id < 0 or worker_id >= self._num_workers:
            raise ValueError(f"worker_id {worker_id} out of range [0, {self._num_workers})")

        await self._channel.send(MSG_SEND, {
            "worker_id": worker_id,
            "key": key,
            "data": data,
        })

    async def recv(self, timeout: float | None = None) -> WorkerMessage:
        """Receive a message from any worker."""
        if not self._running:
            raise PoolNotStarted("Pool not created")

        try:
            if timeout is None:
                data = await self._recv_queue.get()
            else:
                data = await asyncio.wait_for(
                    self._recv_queue.get(),
                    timeout=timeout,
                )
            return WorkerMessage(
                worker_id=data["worker_id"],
                key=data["key"],
                data=data["data"],
            )
        except TimeoutError:
            raise RecvTimeout(f"Receive timed out after {timeout}s")

    async def try_recv(self) -> WorkerMessage | None:
        """Non-blocking receive from any worker."""
        if not self._running:
            raise PoolNotStarted("Pool not created")

        try:
            data = self._recv_queue.get_nowait()
            return WorkerMessage(
                worker_id=data["worker_id"],
                key=data["key"],
                data=data["data"],
            )
        except asyncio.QueueEmpty:
            return None

    async def broadcast(self, key: str, data: Any) -> None:
        """Send a message to all workers."""
        if not self._running or self._channel is None:
            raise PoolNotStarted("Pool not created")

        await self._channel.send(MSG_BROADCAST, {
            "key": key,
            "data": data,
        })

    async def __aenter__(self) -> "RemotePoolClient":
        """Context manager entry - connects to server."""
        await self.connect()
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb) -> None:
        """Context manager exit - closes connection."""
        await self.close()
