# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/netrun/03_pool/04_aio.ipynb

__all__ = ['AsyncWorkerFn', 'SingleWorkerPool']

# %% nbs/netrun/03_pool/04_aio.ipynb 3
import asyncio
from collections.abc import Awaitable, Callable
from typing import Any

from ..pool.base import (
    PoolAlreadyStarted,
    PoolNotStarted,
    WorkerId,
    WorkerMessage,
)
from ..rpc.aio import (
    AsyncChannel,
    create_async_channel_pair,
)
from ..rpc.base import ChannelClosed, RecvTimeout

# %% nbs/netrun/03_pool/04_aio.ipynb 5
AsyncWorkerFn = Callable[[AsyncChannel, WorkerId], Awaitable[None]]
"""Type for async worker functions: async def worker(channel, worker_id) -> None"""

# %% nbs/netrun/03_pool/04_aio.ipynb 7
class SingleWorkerPool:
    """A pool with a single async worker coroutine.

    Designed for the main thread of netrun where the "worker" is
    an async coroutine running in the same event loop. Unlike ThreadPool
    or MultiprocessPool, this does not spawn threads or processes.
    """

    def __init__(
        self,
        worker_fn: AsyncWorkerFn,
    ):
        """Create a single-worker async pool.

        Args:
            worker_fn: Async function to run as the worker.
                       Signature: async def worker(channel: AsyncChannel, worker_id: int) -> None
        """
        self._worker_fn = worker_fn
        self._running = False

        # Will be populated on start()
        self._channel: AsyncChannel | None = None
        self._worker_channel: AsyncChannel | None = None
        self._worker_task: asyncio.Task | None = None
        self._recv_queue: asyncio.Queue = asyncio.Queue()
        self._recv_task: asyncio.Task | None = None

    @property
    def num_workers(self) -> int:
        """Total number of workers in the pool. Always 1."""
        return 1

    @property
    def is_running(self) -> bool:
        """Whether the pool has been started."""
        return self._running

    async def start(self) -> None:
        """Start the worker."""
        if self._running:
            raise PoolAlreadyStarted("Pool is already running")

        self._channel, self._worker_channel = create_async_channel_pair()

        # Start worker as an async task
        self._worker_task = asyncio.create_task(
            self._run_worker()
        )
        self._running = True

    async def _run_worker(self) -> None:
        """Run the worker function."""
        try:
            await self._worker_fn(self._worker_channel, 0)
        except ChannelClosed:
            pass
        except Exception as e:
            # Try to send error back
            try:
                await self._worker_channel.send("__error__", str(e))
            except Exception:
                pass

    async def close(self, timeout: float | None = None) -> None:
        """Shut down the worker and clean up resources.

        Args:
            timeout: Max seconds to wait for the worker task to finish.
                     If None, wait indefinitely. Note: asyncio tasks are
                     cancelled, so timeout mainly affects graceful shutdown.
        """
        if not self._running:
            return

        self._running = False

        # Close the channel to signal worker to stop
        if self._channel:
            await self._channel.close()

        # Cancel recv task if running
        if self._recv_task and not self._recv_task.done():
            self._recv_task.cancel()
            try:
                await self._recv_task
            except asyncio.CancelledError:
                pass

        # Wait for worker task to finish
        if self._worker_task and not self._worker_task.done():
            if timeout is not None:
                try:
                    await asyncio.wait_for(self._worker_task, timeout=timeout)
                except TimeoutError:
                    self._worker_task.cancel()
                    try:
                        await self._worker_task
                    except asyncio.CancelledError:
                        pass
            else:
                # Wait indefinitely for graceful shutdown
                try:
                    await self._worker_task
                except asyncio.CancelledError:
                    pass

        self._channel = None
        self._worker_channel = None
        self._worker_task = None
        self._recv_queue = asyncio.Queue()
        self._recv_task = None

    async def send(self, worker_id: WorkerId, key: str, data: Any) -> None:
        """Send a message to the worker."""
        if not self._running:
            raise PoolNotStarted("Pool has not been started")

        if worker_id != 0:
            raise ValueError(f"worker_id must be 0, got {worker_id}")

        await self._channel.send(key, data)

    def _start_recv_task(self) -> None:
        """Start background task that forwards messages to the queue."""
        if self._recv_task is not None:
            return

        async def recv_loop():
            try:
                while self._running:
                    key, data = await self._channel.recv()
                    msg = WorkerMessage(worker_id=0, key=key, data=data)
                    await self._recv_queue.put(msg)
            except (ChannelClosed, asyncio.CancelledError):
                pass
            except Exception:
                pass

        self._recv_task = asyncio.create_task(recv_loop())

    async def recv(self, timeout: float | None = None) -> WorkerMessage:
        """Receive a message from the worker."""
        if not self._running:
            raise PoolNotStarted("Pool has not been started")

        self._start_recv_task()

        try:
            if timeout is None:
                return await self._recv_queue.get()
            else:
                return await asyncio.wait_for(
                    self._recv_queue.get(),
                    timeout=timeout,
                )
        except TimeoutError:
            raise RecvTimeout(f"Receive timed out after {timeout}s")

    async def try_recv(self) -> WorkerMessage | None:
        """Non-blocking receive from the worker."""
        if not self._running:
            raise PoolNotStarted("Pool has not been started")

        result = await self._channel.try_recv()
        if result is not None:
            key, data = result
            return WorkerMessage(worker_id=0, key=key, data=data)

        return None

    async def broadcast(self, key: str, data: Any) -> None:
        """Send a message to the worker (same as send for single worker)."""
        if not self._running:
            raise PoolNotStarted("Pool has not been started")

        await self._channel.send(key, data)

    async def __aenter__(self) -> "SingleWorkerPool":
        """Context manager entry - starts the pool."""
        await self.start()
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb) -> None:
        """Context manager exit - closes the pool."""
        await self.close()
