# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/netrun/01_iutils/01_hashing.ipynb

__all__ = ['HashMethod', 'adler32', 'blake2b', 'crc32', 'hash', 'sha256', 'xxh64']

# %% nbs/netrun/01_iutils/01_hashing.ipynb 2
import binascii
import hashlib
import pickle
import pickletools
import struct
import zlib
from enum import Enum
from typing import Any

import xxhash


# %% nbs/netrun/01_iutils/01_hashing.ipynb 5
def _to_bytes(data: Any, pickle_protocol: int):
    """
    Converts data to bytes for hashing.
    """
    type_data = type(data)

    if type_data is bytes:
        return data
    elif type_data is str:
        return data.encode("utf-8")
    elif type_data is int:
        return data.to_bytes((data.bit_length() + 8) // 8, byteorder="big", signed=True)
    elif type_data is float:
        return struct.pack("!d", data)
    else:
        _data = pickle.dumps(data, protocol=pickle_protocol)
        return pickletools.optimize(_data)

# %% nbs/netrun/01_iutils/01_hashing.ipynb 7
def adler32(data: Any, pickle_protocol: int) -> int:
    """
    Compute portable hash for given data.
    """
    mask = 0xFFFFFFFF
    _bdata = _to_bytes(data, pickle_protocol=pickle_protocol)
    return zlib.adler32(_bdata) & mask

# %% nbs/netrun/01_iutils/01_hashing.ipynb 9
def crc32(data: Any, pickle_protocol: int) -> int:
    """
    Compute portable hash using CRC32.
    """
    mask = 0xFFFFFFFF
    _bdata = _to_bytes(data, pickle_protocol=pickle_protocol)
    return binascii.crc32(_bdata) & mask

# %% nbs/netrun/01_iutils/01_hashing.ipynb 11
def sha256(data: Any, pickle_protocol: int) -> int:
    """
    Compute hash using SHA-256.
    """
    _bdata = _to_bytes(data, pickle_protocol=pickle_protocol)
    return int.from_bytes(hashlib.sha256(_bdata).digest(), byteorder="big")

# %% nbs/netrun/01_iutils/01_hashing.ipynb 13
def blake2b(data: Any, pickle_protocol: int) -> int:
    """
    Compute hash using BLAKE2b.
    """
    _bdata = _to_bytes(data, pickle_protocol=pickle_protocol)
    return int.from_bytes(hashlib.blake2b(_bdata).digest(), byteorder="big")

# %% nbs/netrun/01_iutils/01_hashing.ipynb 15
def xxh64(data: Any, pickle_protocol: int) -> int:
    """
    Compute hash using xxHash (64-bit).
    """
    _bdata = _to_bytes(data, pickle_protocol=pickle_protocol)
    return xxhash.xxh64(_bdata).intdigest()

# %% nbs/netrun/01_iutils/01_hashing.ipynb 17
class HashMethod(Enum):
    adler32 = "adler32"
    crc32 = "crc32"
    sha256 = "sha256"
    blake2b = "blake2b"
    xxh64 = "xxh64"

def hash(data: Any, method: HashMethod, pickle_protocol: int) -> int:
    if method == HashMethod.adler32:
        return adler32(data, pickle_protocol=pickle_protocol)
    elif method == HashMethod.crc32:
        return crc32(data, pickle_protocol=pickle_protocol)
    elif method == HashMethod.sha256:
        return sha256(data, pickle_protocol=pickle_protocol)
    elif method == HashMethod.blake2b:
        return blake2b(data, pickle_protocol=pickle_protocol)
    elif method == HashMethod.xxh64:
        return xxh64(data, pickle_protocol=pickle_protocol)
    else:
        raise ValueError(f"Invalid hash method: {method}")
