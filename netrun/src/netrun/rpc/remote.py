# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/netrun/02_rpc/04_remote.ipynb

__all__ = ['ConnectionHandler', 'WebSocketChannel', 'connect', 'connect_channel', 'serve', 'serve_background']

# %% nbs/netrun/02_rpc/04_remote.ipynb 3
import asyncio
import json
import pickle
from collections.abc import Awaitable, Callable
from contextlib import asynccontextmanager
from typing import Any

from ..rpc.base import (
    SHUTDOWN_KEY,
    ChannelBroken,
    ChannelClosed,
    RecvTimeout,
)


# %% nbs/netrun/02_rpc/04_remote.ipynb 5
class WebSocketChannel:
    """Async RPC channel over a WebSocket connection.

    Messages are serialized using pickle (for data) wrapped in JSON (for metadata).
    Thread-safe for use from multiple coroutines.

    Wire format:
        {"key": str, "data_hex": str}
        where data_hex is hex-encoded pickled data
    """

    def __init__(self, websocket):
        """Create a channel from a websocket connection.

        Args:
            websocket: A websockets WebSocket connection
        """
        self._ws = websocket
        self._closed = False
        self._recv_queue: asyncio.Queue = asyncio.Queue()
        self._recv_task: asyncio.Task | None = None

    async def _start_receiver(self) -> None:
        """Start the background receiver task."""
        if self._recv_task is None:
            self._recv_task = asyncio.create_task(self._receiver_loop())

    async def _receiver_loop(self) -> None:
        """Background task that receives messages and queues them."""
        try:
            async for message in self._ws:
                try:
                    data = json.loads(message)
                    key = data["key"]
                    payload = pickle.loads(bytes.fromhex(data["data_hex"]))
                    await self._recv_queue.put((key, payload))
                except Exception as e:
                    await self._recv_queue.put(("__error__", str(e)))
        except Exception as e:
            if not self._closed:
                await self._recv_queue.put(("__broken__", str(e)))
        finally:
            self._closed = True

    async def send(self, key: str, data: Any) -> None:
        """Send a message."""
        if self._closed:
            raise ChannelClosed("Channel is closed")

        try:
            message = json.dumps({
                "key": key,
                "data_hex": pickle.dumps(data).hex(),
            })
            await self._ws.send(message)
        except Exception as e:
            self._closed = True
            raise ChannelBroken(f"Failed to send: {e}")

    async def recv(self, timeout: float | None = None) -> tuple[str, Any]:
        """Receive a message with optional timeout."""
        if self._closed and self._recv_queue.empty():
            raise ChannelClosed("Channel is closed")

        await self._start_receiver()

        try:
            if timeout is None:
                result = await self._recv_queue.get()
            else:
                result = await asyncio.wait_for(
                    self._recv_queue.get(),
                    timeout=timeout,
                )
        except TimeoutError:
            raise RecvTimeout(f"Receive timed out after {timeout}s")

        key, data = result

        if key == SHUTDOWN_KEY:
            self._closed = True
            raise ChannelClosed("Channel was shut down")
        if key == "__broken__":
            self._closed = True
            raise ChannelBroken(f"Connection broken: {data}")
        if key == "__error__":
            raise ChannelBroken(f"Receive error: {data}")

        return key, data

    async def try_recv(self) -> tuple[str, Any] | None:
        """Non-blocking receive."""
        if self._closed and self._recv_queue.empty():
            raise ChannelClosed("Channel is closed")

        await self._start_receiver()

        try:
            result = self._recv_queue.get_nowait()
        except asyncio.QueueEmpty:
            return None

        key, data = result

        if key == SHUTDOWN_KEY:
            self._closed = True
            raise ChannelClosed("Channel was shut down")
        if key == "__broken__":
            self._closed = True
            raise ChannelBroken(f"Connection broken: {data}")

        return key, data

    async def close(self) -> None:
        """Close the channel."""
        if not self._closed:
            self._closed = True
            try:
                await self._ws.send(json.dumps({
                    "key": SHUTDOWN_KEY,
                    "data_hex": pickle.dumps(None).hex(),
                }))
            except Exception:
                pass
            try:
                await self._ws.close()
            except Exception:
                pass
            if self._recv_task and not self._recv_task.done():
                self._recv_task.cancel()
                try:
                    await self._recv_task
                except asyncio.CancelledError:
                    pass

    @property
    def is_closed(self) -> bool:
        """Whether the channel is closed."""
        return self._closed

# %% nbs/netrun/02_rpc/04_remote.ipynb 7
@asynccontextmanager
async def connect(url: str):
    """Connect to a WebSocket RPC server.

    Args:
        url: WebSocket URL (e.g., "ws://host:port")

    Yields:
        WebSocketChannel for communication with the server.

    Example:
        ```python
        async with connect("ws://localhost:8080") as channel:
            await channel.send("hello", "world")
            key, data = await channel.recv()
        ```
    """
    try:
        import websockets
    except ImportError:
        raise ImportError(
            "websockets package required. Install with: pip install websockets"
        )

    try:
        websocket = await websockets.connect(url)
    except Exception as e:
        raise ConnectionError(f"Failed to connect to {url}: {e}")

    channel = WebSocketChannel(websocket)
    try:
        yield channel
    finally:
        await channel.close()

# %% nbs/netrun/02_rpc/04_remote.ipynb 8
async def connect_channel(url: str) -> WebSocketChannel:
    """Connect to a WebSocket RPC server (non-context manager version).

    Args:
        url: WebSocket URL (e.g., "ws://host:port")

    Returns:
        WebSocketChannel for communication with the server.
        Caller is responsible for closing the channel.

    Example:
        ```python
        channel = await connect_channel("ws://localhost:8080")
        try:
            await channel.send("hello", "world")
            key, data = await channel.recv()
        finally:
            await channel.close()
        ```
    """
    try:
        import websockets
    except ImportError:
        raise ImportError(
            "websockets package required. Install with: pip install websockets"
        )

    try:
        websocket = await websockets.connect(url)
    except Exception as e:
        raise ConnectionError(f"Failed to connect to {url}: {e}")

    return WebSocketChannel(websocket)

# %% nbs/netrun/02_rpc/04_remote.ipynb 10
ConnectionHandler = Callable[[WebSocketChannel], Awaitable[None]]
"""Type for connection handler functions."""

# %% nbs/netrun/02_rpc/04_remote.ipynb 11
async def serve(
    handler: ConnectionHandler,
    host: str = "0.0.0.0",
    port: int = 8080,
) -> None:
    """Run a WebSocket RPC server.

    Accepts connections and runs the handler for each client.
    Blocks until the server is stopped (e.g., by KeyboardInterrupt).

    Args:
        handler: Async function called for each connection with a WebSocketChannel
        host: Host to bind to (default all interfaces)
        port: Port to listen on

    Example:
        ```python
        async def handle_client(channel: WebSocketChannel):
            while True:
                key, data = await channel.recv()
                result = process(data)
                await channel.send("result", result)

        # Run server (blocks until stopped)
        await serve(handle_client, port=8080)
        ```
    """
    try:
        import websockets
    except ImportError:
        raise ImportError(
            "websockets package required. Install with: pip install websockets"
        )

    async def handle_connection(websocket):
        channel = WebSocketChannel(websocket)
        try:
            await handler(channel)
        except ChannelClosed:
            pass
        finally:
            if not channel.is_closed:
                await channel.close()

    server = await websockets.serve(handle_connection, host, port)
    print(f"RPC server listening on ws://{host}:{port}")

    try:
        await server.wait_closed()
    except asyncio.CancelledError:
        pass
    finally:
        server.close()
        await server.wait_closed()

# %% nbs/netrun/02_rpc/04_remote.ipynb 12
@asynccontextmanager
async def serve_background(
    handler: ConnectionHandler,
    host: str = "0.0.0.0",
    port: int = 8080,
):
    """Run a WebSocket RPC server in the background.

    Starts the server and yields control. Server stops when context exits.

    Args:
        handler: Async function called for each connection with a WebSocketChannel
        host: Host to bind to (default all interfaces)
        port: Port to listen on

    Yields:
        The websockets server object (for inspection).

    Example:
        ```python
        async def handle_client(channel):
            key, data = await channel.recv()
            await channel.send("echo", data)

        async with serve_background(handle_client, port=8080) as server:
            # Server is running, do other things
            async with connect("ws://localhost:8080") as client:
                await client.send("hello", "world")
                key, data = await client.recv()
        # Server stops when context exits
        ```
    """
    try:
        import websockets
    except ImportError:
        raise ImportError(
            "websockets package required. Install with: pip install websockets"
        )

    async def handle_connection(websocket):
        channel = WebSocketChannel(websocket)
        try:
            await handler(channel)
        except ChannelClosed:
            pass
        finally:
            if not channel.is_closed:
                await channel.close()

    server = await websockets.serve(handle_connection, host, port)
    try:
        yield server
    finally:
        server.close()
        await server.wait_closed()
