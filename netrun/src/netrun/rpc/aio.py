# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/netrun/02_rpc/01_aio.ipynb

__all__ = ['AsyncChannel', 'create_async_channel_pair']

# %% nbs/netrun/02_rpc/01_aio.ipynb 3
import asyncio
from typing import Any

from ..rpc.base import (
    SHUTDOWN_KEY,
    ChannelClosed,
    RecvTimeout,
)


# %% nbs/netrun/02_rpc/01_aio.ipynb 5
class AsyncChannel:
    """Async RPC channel using asyncio queues.

    For communication between async tasks in the same event loop.
    Safe for use from multiple coroutines.

    Note: This is NOT for OS thread communication. Use ThreadChannel
    from the thread module for that.
    """

    def __init__(
        self,
        send_queue: asyncio.Queue,
        recv_queue: asyncio.Queue,
    ):
        """Create a channel from two queues.

        Args:
            send_queue: Queue for outgoing messages
            recv_queue: Queue for incoming messages
        """
        self._send_queue = send_queue
        self._recv_queue = recv_queue
        self._closed = False

    async def send(self, key: str, data: Any) -> None:
        """Send a message."""
        if self._closed:
            raise ChannelClosed("Channel is closed")
        await self._send_queue.put((key, data))

    async def recv(self, timeout: float | None = None) -> tuple[str, Any]:
        """Receive a message with optional timeout."""
        if self._closed:
            raise ChannelClosed("Channel is closed")

        try:
            if timeout is None:
                result = await self._recv_queue.get()
            else:
                result = await asyncio.wait_for(
                    self._recv_queue.get(),
                    timeout=timeout,
                )
        except TimeoutError:
            raise RecvTimeout(f"Receive timed out after {timeout}s")

        if result[0] == SHUTDOWN_KEY:
            self._closed = True
            raise ChannelClosed("Channel was shut down")

        return result

    async def try_recv(self) -> tuple[str, Any] | None:
        """Non-blocking receive."""
        if self._closed:
            raise ChannelClosed("Channel is closed")

        try:
            result = self._recv_queue.get_nowait()
        except asyncio.QueueEmpty:
            return None

        if result[0] == SHUTDOWN_KEY:
            self._closed = True
            raise ChannelClosed("Channel was shut down")

        return result

    async def close(self) -> None:
        """Close the channel."""
        if not self._closed:
            self._closed = True
            try:
                await self._send_queue.put((SHUTDOWN_KEY, None))
            except Exception:
                pass

    @property
    def is_closed(self) -> bool:
        """Whether the channel is closed."""
        return self._closed

# %% nbs/netrun/02_rpc/01_aio.ipynb 7
def create_async_channel_pair() -> tuple[AsyncChannel, AsyncChannel]:
    """Create a pair of connected AsyncChannels.

    Returns:
        (channel_a, channel_b) where messages sent on one are received on the other.

    Example:
        ```python
        ch_a, ch_b = create_async_channel_pair()

        await ch_a.send("hello", "world")
        key, data = await ch_b.recv()  # ("hello", "world")

        await ch_b.send("reply", 42)
        key, data = await ch_a.recv()  # ("reply", 42)
        ```
    """
    queue_a_to_b: asyncio.Queue = asyncio.Queue()
    queue_b_to_a: asyncio.Queue = asyncio.Queue()

    channel_a = AsyncChannel(send_queue=queue_a_to_b, recv_queue=queue_b_to_a)
    channel_b = AsyncChannel(send_queue=queue_b_to_a, recv_queue=queue_a_to_b)

    return channel_a, channel_b
