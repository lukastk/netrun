# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/netrun/02_rpc/02_process.ipynb

__all__ = ['ProcessChannel', 'SyncProcessChannel', 'create_queue_pair']

# %% nbs/netrun/02_rpc/02_process.ipynb 3
import asyncio
import multiprocessing as mp
import queue
import threading
from concurrent.futures import ThreadPoolExecutor
from typing import Any

from ..rpc.base import (
    SHUTDOWN_KEY,
    ChannelBroken,
    ChannelClosed,
    RecvTimeout,
)


# %% nbs/netrun/02_rpc/02_process.ipynb 5
class SyncProcessChannel:
    """Synchronous RPC channel over multiprocessing queues.

    For use in worker subprocesses. Thread-safe.
    """

    def __init__(
        self,
        send_queue: mp.Queue,
        recv_queue: mp.Queue,
    ):
        """Create a channel from multiprocessing queues.

        Args:
            send_queue: Queue for outgoing messages (to parent)
            recv_queue: Queue for incoming messages (from parent)
        """
        self._send_queue = send_queue
        self._recv_queue = recv_queue
        self._closed = False
        self._lock = threading.Lock()

    def send(self, key: str, data: Any) -> None:
        """Send a message."""
        if self._closed:
            raise ChannelClosed("Channel is closed")

        try:
            self._send_queue.put((key, data))
        except (BrokenPipeError, EOFError, OSError) as e:
            self._closed = True
            raise ChannelBroken(f"Channel broken: {e}")

    def recv(self, timeout: float | None = None) -> tuple[str, Any]:
        """Receive a message with optional timeout."""
        if self._closed:
            raise ChannelClosed("Channel is closed")

        try:
            result = self._recv_queue.get(timeout=timeout)
        except queue.Empty:
            raise RecvTimeout(f"Receive timed out after {timeout}s")
        except (BrokenPipeError, EOFError, OSError) as e:
            self._closed = True
            raise ChannelBroken(f"Channel broken: {e}")

        if result[0] == SHUTDOWN_KEY:
            self._closed = True
            raise ChannelClosed("Channel was shut down")

        return result

    def try_recv(self) -> tuple[str, Any] | None:
        """Non-blocking receive."""
        if self._closed:
            raise ChannelClosed("Channel is closed")

        try:
            result = self._recv_queue.get_nowait()
        except queue.Empty:
            return None
        except (BrokenPipeError, EOFError, OSError) as e:
            self._closed = True
            raise ChannelBroken(f"Channel broken: {e}")

        if result[0] == SHUTDOWN_KEY:
            self._closed = True
            raise ChannelClosed("Channel was shut down")

        return result

    def close(self) -> None:
        """Close the channel."""
        with self._lock:
            if not self._closed:
                self._closed = True
                try:
                    self._send_queue.put_nowait((SHUTDOWN_KEY, None))
                except Exception:
                    pass

    @property
    def is_closed(self) -> bool:
        return self._closed

# %% nbs/netrun/02_rpc/02_process.ipynb 7
class ProcessChannel:
    """Async RPC channel over multiprocessing queues.

    For use in the parent process. Thread-safe.
    """

    def __init__(
        self,
        send_queue: mp.Queue,
        recv_queue: mp.Queue,
        executor: ThreadPoolExecutor | None = None,
    ):
        """Create a channel from multiprocessing queues.

        Args:
            send_queue: Queue for outgoing messages (to child)
            recv_queue: Queue for incoming messages (from child)
            executor: Thread pool for async operations (created if None)
        """
        self._send_queue = send_queue
        self._recv_queue = recv_queue
        self._executor = executor or ThreadPoolExecutor(max_workers=2)
        self._owns_executor = executor is None
        self._closed = False
        self._lock = threading.Lock()

    async def send(self, key: str, data: Any) -> None:
        """Send a message."""
        if self._closed:
            raise ChannelClosed("Channel is closed")

        loop = asyncio.get_running_loop()
        try:
            await loop.run_in_executor(
                self._executor,
                self._send_queue.put,
                (key, data),
            )
        except (BrokenPipeError, EOFError, OSError) as e:
            self._closed = True
            raise ChannelBroken(f"Channel broken: {e}")

    async def recv(self, timeout: float | None = None) -> tuple[str, Any]:
        """Receive a message with optional timeout."""
        if self._closed:
            raise ChannelClosed("Channel is closed")

        loop = asyncio.get_running_loop()

        def blocking_recv():
            try:
                return self._recv_queue.get(timeout=timeout)
            except queue.Empty:
                raise RecvTimeout(f"Receive timed out after {timeout}s")

        try:
            result = await loop.run_in_executor(self._executor, blocking_recv)
        except RecvTimeout:
            raise
        except (BrokenPipeError, EOFError, OSError) as e:
            self._closed = True
            raise ChannelBroken(f"Channel broken: {e}")

        if result[0] == SHUTDOWN_KEY:
            self._closed = True
            raise ChannelClosed("Channel was shut down")

        return result

    async def try_recv(self) -> tuple[str, Any] | None:
        """Non-blocking receive."""
        if self._closed:
            raise ChannelClosed("Channel is closed")

        try:
            result = self._recv_queue.get_nowait()
        except queue.Empty:
            return None
        except (BrokenPipeError, EOFError, OSError) as e:
            self._closed = True
            raise ChannelBroken(f"Channel broken: {e}")

        if result[0] == SHUTDOWN_KEY:
            self._closed = True
            raise ChannelClosed("Channel was shut down")

        return result

    async def close(self) -> None:
        """Close the channel."""
        with self._lock:
            if not self._closed:
                self._closed = True
                try:
                    self._send_queue.put_nowait((SHUTDOWN_KEY, None))
                except Exception:
                    pass

                if self._owns_executor:
                    self._executor.shutdown(wait=False)

    @property
    def is_closed(self) -> bool:
        return self._closed

# %% nbs/netrun/02_rpc/02_process.ipynb 9
def create_queue_pair(
    ctx: mp.context.BaseContext | None = None,
) -> tuple[ProcessChannel, tuple[mp.Queue, mp.Queue]]:
    """Create queues and a parent channel for subprocess communication.

    Args:
        ctx: Multiprocessing context (uses spawn by default)

    Returns:
        (parent_channel, (child_send_queue, child_recv_queue))

    Example:
        ```python
        import multiprocessing as mp
        from ..rpc.process import create_queue_pair, SyncProcessChannel

        def worker(send_q, recv_q):
            channel = SyncProcessChannel(send_q, recv_q)
            key, data = channel.recv()
            channel.send("echo", data)

        parent_channel, child_queues = create_queue_pair()
        proc = mp.Process(target=worker, args=child_queues)
        proc.start()

        await parent_channel.send("hello", "world")
        key, data = await parent_channel.recv()
        ```
    """
    if ctx is None:
        ctx = mp.get_context("spawn")

    parent_to_child = ctx.Queue()
    child_to_parent = ctx.Queue()

    parent_channel = ProcessChannel(
        send_queue=parent_to_child,
        recv_queue=child_to_parent,
    )

    # Child gets queues in opposite order
    child_queues = (child_to_parent, parent_to_child)

    return parent_channel, child_queues
