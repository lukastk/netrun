# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/examples/02_error_handling.ipynb

__all__ = ['call_count', 'dlq_entries', 'edges', 'error_callback', 'error_log', 'execution_log', 'fail_rate', 'graph', 'net', 'net_raise', 'processor_exec', 'processor_exec_raise', 'processor_failed', 'processor_node', 'results', 'sink_exec', 'sink_exec_raise', 'sink_node', 'source_exec', 'source_exec_raise', 'source_node']

# %% nbs/examples/02_error_handling.ipynb 2
import random
from netrun.core import (
    # Graph building
    Graph,
    Node,
    Edge,
    Port,
    PortType,
    PortRef,
    PortState,
    MaxSalvos,
    SalvoCondition,
    SalvoConditionTerm,
    # Net and configuration
    Net,
    NetState,
    # DLQ
    DeadLetterEntry,
)

# %% nbs/examples/02_error_handling.ipynb 4
source_node = Node(
    name="Source",
    out_ports={"out": Port()},
    out_salvo_conditions={
        "send": SalvoCondition(
            MaxSalvos.infinite(),
            "out",
            SalvoConditionTerm.port("out", PortState.non_empty())
        )
    }
)

processor_node = Node(
    name="Processor",
    in_ports={"in": Port()},
    out_ports={"out": Port()},
    in_salvo_conditions={
        "receive": SalvoCondition(
            MaxSalvos.finite(1),
            "in",
            SalvoConditionTerm.port("in", PortState.non_empty())
        )
    },
    out_salvo_conditions={
        "send": SalvoCondition(
            MaxSalvos.infinite(),
            "out",
            SalvoConditionTerm.port("out", PortState.non_empty())
        )
    }
)

sink_node = Node(
    name="Sink",
    in_ports={"in": Port()},
    in_salvo_conditions={
        "receive": SalvoCondition(
            MaxSalvos.finite(1),
            "in",
            SalvoConditionTerm.port("in", PortState.non_empty())
        )
    }
)

edges = [
    Edge(
        PortRef("Source", PortType.Output, "out"),
        PortRef("Processor", PortType.Input, "in")
    ),
    Edge(
        PortRef("Processor", PortType.Output, "out"),
        PortRef("Sink", PortType.Input, "in")
    ),
]

graph = Graph([source_node, processor_node, sink_node], edges)
print(f"Created pipeline: {list(graph.nodes().keys())}")

# %% nbs/examples/02_error_handling.ipynb 6
# Track errors for demonstration
error_log = []

def error_callback(exception, node_name, epoch_id):
    """Called when a node fails after all retries."""
    error_log.append({
        "node": node_name,
        "error": str(exception),
        "epoch_id": epoch_id[:8] + "...",
    })
    print(f"[ERROR] {node_name} failed: {exception}")

# Create net with error handling configured
net = Net(
    graph,
    consumed_packet_storage=True,
    on_error="continue",  # Keep running on errors
    error_callback=error_callback,
    dead_letter_queue="memory",
)

print(f"Created Net with on_error='{net._on_error}'")

# %% nbs/examples/02_error_handling.ipynb 8
# Tracking for demonstration
execution_log = []
results = []

# Simulate unreliable processing
fail_rate = 0.6
random.seed(42)  # For reproducibility

def source_exec(ctx, packets):
    """Generate multiple data packets."""
    execution_log.append(f"Source: generating packets")
    for i in range(3):
        pkt = ctx.create_packet({"id": i, "data": f"item-{i}"})
        ctx.load_output_port("out", pkt)
        ctx.send_output_salvo("send")
    execution_log.append(f"Source: sent 3 packets")

def processor_exec(ctx, packets):
    """Process data with simulated failures."""
    for port_name, pkts in packets.items():
        for pkt in pkts:
            value = ctx.consume_packet(pkt)

            # Simulate unreliable processing
            # Fail more often on first attempts, less on retries
            adjusted_fail_rate = fail_rate / (ctx.retry_count + 1)
            if random.random() < adjusted_fail_rate:
                execution_log.append(
                    f"Processor: FAILED on {value['id']} (attempt {ctx.retry_count + 1})"
                )
                raise RuntimeError(f"Processing failed for item {value['id']}")

            execution_log.append(
                f"Processor: processed {value['id']} (attempt {ctx.retry_count + 1})"
            )

            # Create output
            output = {**value, "processed": True}
            out_pkt = ctx.create_packet(output)
            ctx.load_output_port("out", out_pkt)
            ctx.send_output_salvo("send")

def processor_failed(failure_ctx):
    """Called after each failure."""
    execution_log.append(
        f"Processor: failed_func called (retry {failure_ctx.retry_count})"
    )

def sink_exec(ctx, packets):
    """Collect processed results."""
    for port_name, pkts in packets.items():
        for pkt in pkts:
            value = ctx.consume_packet(pkt)
            results.append(value)
            execution_log.append(f"Sink: received {value['id']}")

# Register execution functions
net.set_node_exec("Source", source_exec)
net.set_node_exec("Processor", processor_exec, failed_func=processor_failed)
net.set_node_exec("Sink", sink_exec)

# Configure Processor with retries
net.set_node_config(
    "Processor",
    retries=3,               # Up to 3 retries (4 total attempts)
    retry_wait=0.01,         # Small delay between retries
    defer_net_actions=True,  # Required for retries
)

print("Node functions and retry configuration set up")

# %% nbs/examples/02_error_handling.ipynb 10
# Clear tracking
execution_log.clear()
results.clear()
error_log.clear()

# Inject source epoch
net.inject_source_epoch("Source")

print("Running pipeline with unreliable Processor...\n")
net.start()

print("\n--- Execution Log ---")
for entry in execution_log:
    print(f"  {entry}")

# %% nbs/examples/02_error_handling.ipynb 12
print("\n--- Results ---")
print(f"Successfully processed: {len(results)} items")
for r in results:
    print(f"  {r}")

print(f"\n--- Dead Letter Queue ---")
dlq_entries = net.dead_letter_queue.get_all()
print(f"Failed items in DLQ: {len(dlq_entries)}")
for entry in dlq_entries:
    print(f"  Node: {entry.node_name}")
    print(f"  Error: {entry.exception}")
    print(f"  Retries: {entry.retry_count}")
    print(f"  Input packets: {entry.input_packets}")

print(f"\n--- Error Log ---")
print(f"Total errors (after retries exhausted): {len(error_log)}")
for err in error_log:
    print(f"  {err}")

# %% nbs/examples/02_error_handling.ipynb 14
print("\n" + "="*60)
print("Demonstrating on_error='raise' mode")
print("="*60 + "\n")

# Create a new net with raise mode
net_raise = Net(
    graph,
    on_error="raise",  # Raise exception on error
)

call_count = [0]

def source_exec_raise(ctx, packets):
    pkt = ctx.create_packet({"id": 0})
    ctx.load_output_port("out", pkt)
    ctx.send_output_salvo("send")

def processor_exec_raise(ctx, packets):
    call_count[0] += 1
    raise ValueError("Always fails!")

def sink_exec_raise(ctx, packets):
    pass

net_raise.set_node_exec("Source", source_exec_raise)
net_raise.set_node_exec("Processor", processor_exec_raise)
net_raise.set_node_exec("Sink", sink_exec_raise)

net_raise.inject_source_epoch("Source")

try:
    net_raise.start()
except Exception as e:
    print(f"Caught exception: {type(e).__name__}")
    print(f"  Message: {e}")
    print(f"  Net state: {net_raise.state}")
